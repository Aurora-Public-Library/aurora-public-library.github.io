"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = manageFocus;
exports.shouldAllowForwardTab = exports.shouldAllowBackwardTab = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _first2 = _interopRequireDefault(require("lodash/first"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _tabbable = require("tabbable");

var _reactDisplayName = _interopRequireDefault(require("react-display-name"));

var _utilsAccessibility = require("@bibliocommons/utils-accessibility");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var TAB_KEYCODE = 9;
/**
 * Returns true if nodeA comes after nodeB in the DOM
 */
// eslint-disable-next-line no-bitwise

var nodeIsAfter = function nodeIsAfter(nodeA, nodeB) {
  return !!(nodeA.compareDocumentPosition(nodeB) & Node.DOCUMENT_POSITION_PRECEDING);
};
/**
 * Returns true if nodeA comes before nodeB in the DOM
 */
// eslint-disable-next-line no-bitwise


var nodeIsBefore = function nodeIsBefore(nodeA, nodeB) {
  return !!(nodeA.compareDocumentPosition(nodeB) & Node.DOCUMENT_POSITION_FOLLOWING);
};

var isSameTabbableElement = function isSameTabbableElement(target, compareTo) {
  if (target === compareTo) {
    return true;
  } // Radio buttons are in the same tabbable group but there are special rules to determine which can be tabbed to
  // We don't care about those and just want to know if the whole group is the first or last element


  if (target.nodeName === 'INPUT' && target.type === 'radio' && compareTo.nodeName === 'INPUT' && compareTo.type === 'radio') {
    return target.name === compareTo.name;
  }

  return false;
};

var shouldAllowForwardTab = function shouldAllowForwardTab(_ref) {
  var currentElement = _ref.currentElement,
      lastTabbable = _ref.lastTabbable;
  var isAfterLastTabbableElement = nodeIsAfter(currentElement, lastTabbable);
  var isLastTabbableElement = isSameTabbableElement(currentElement, lastTabbable);
  return !isLastTabbableElement && !isAfterLastTabbableElement;
};

exports.shouldAllowForwardTab = shouldAllowForwardTab;

var shouldAllowBackwardTab = function shouldAllowBackwardTab(_ref2) {
  var currentElement = _ref2.currentElement,
      firstTabbable = _ref2.firstTabbable;
  var isBeforeFirstTabbableElement = nodeIsBefore(currentElement, firstTabbable);
  var isFirstTabbableElement = isSameTabbableElement(currentElement, firstTabbable);
  return !isFirstTabbableElement && !isBeforeFirstTabbableElement;
};
/**
 * Higher order component that restricts focus/tabbing to the content with the component
 *
 * @export
 * @param {React.Component} ComposedComponent
 * @returns {React.Component}
 */


exports.shouldAllowBackwardTab = shouldAllowBackwardTab;

function manageFocus(ComposedComponent) {
  var ManageFocus = /*#__PURE__*/function (_React$PureComponent) {
    (0, _inherits2.default)(ManageFocus, _React$PureComponent);

    var _super = _createSuper(ManageFocus);

    function ManageFocus() {
      var _this;

      (0, _classCallCheck2.default)(this, ManageFocus);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._focusCaptured = false;

      _this.captureFocus = function (element, restrictFocus) {
        if (restrictFocus === void 0) {
          restrictFocus = true;
        }

        if (_this._focusCaptured) {
          // captureFocus should not do anything if the focus is already constrained to the element
          return;
        }

        _this._element = element;
        _this._restrictFocus = restrictFocus;

        if (_this._element) {
          _this._focusCaptured = true; // Store previously focused element and focus the mounted component

          _this._previouslyFocusedElement = (0, _utilsAccessibility.getActiveElement)(document);

          if (_this.props.handleFocusOnCapture) {
            _this.props.handleFocusOnCapture(_this._element);
          } else {
            (0, _utilsAccessibility.setFocusWithinElement)(_this._element);
          }

          if (restrictFocus) {
            _this._element.addEventListener('keydown', _this.handleKeyDown);
          }
        }
      };

      _this.restoreFocus = function (elementToFocusOn) {
        if (!_this._focusCaptured) {
          // restoreFocus cannot be called until captureFocus has been called
          return;
        }

        if (_this._restrictFocus) {
          _this._element.removeEventListener('keydown', _this.handleKeyDown);
        }

        var elementToRestoreFocusTo = elementToFocusOn || _this._previouslyFocusedElement;

        if (_this.props.handleFocusOnRestore) {
          _this.props.handleFocusOnRestore(elementToRestoreFocusTo);
        } else if (elementToRestoreFocusTo.focus) {
          // Restore focus to the previously focused element
          elementToRestoreFocusTo.focus();
        } else {
          (0, _utilsAccessibility.setFocusWithinElement)(elementToRestoreFocusTo);
        }

        _this._element = null;
        _this._previouslyFocusedElement = null;
        _this._focusCaptured = false;
      };

      _this.handleKeyDown = function (e) {
        if (e.keyCode === TAB_KEYCODE) {
          var tabbableElements = (0, _tabbable.tabbable)(_this._element);
          var lastTabbable = (0, _last2.default)(tabbableElements);
          var firstTabbable = (0, _first2.default)(tabbableElements);
          var allowForwardTab = shouldAllowForwardTab({
            currentElement: e.target,
            lastTabbable: lastTabbable
          });
          var allowBackwardTab = shouldAllowBackwardTab({
            currentElement: e.target,
            firstTabbable: firstTabbable
          });

          if (!allowForwardTab && !e.shiftKey) {
            // If this is the last tabbable element in the component,
            // we hijack the Tab key and move focus to the first element
            e.preventDefault();
            firstTabbable.focus();
          } else if (!allowBackwardTab && e.shiftKey) {
            // If this is the first tabbable element in the component and they're holding shift,
            // we hijack the key and move focus to the last element
            e.preventDefault();
            lastTabbable.focus();
          }
        }
      };

      _this.getWrappedInstance = function () {
        return _this._wrappedComponent;
      };

      return _this;
    }

    (0, _createClass2.default)(ManageFocus, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.restoreFocus();
      }
      /**
       * Traps the focus within the element
       *
       * @param {DOMNode} element
       *
       * @memberOf ManageFocus
       */

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var props = _objectSpread(_objectSpread({}, this.props), {}, {
          captureFocus: this.captureFocus,
          restoreFocus: this.restoreFocus
        });

        if (ComposedComponent.prototype instanceof _react.default.Component) {
          props.ref = function (el) {
            return _this2._wrappedComponent = el;
          };
        }

        return /*#__PURE__*/_react.default.createElement(ComposedComponent, props);
      }
    }]);
    return ManageFocus;
  }(_react.default.PureComponent);

  ManageFocus.propTypes = {
    handleFocusOnCapture: _propTypes.default.func,
    handleFocusOnRestore: _propTypes.default.func
  };
  ManageFocus.displayName = "ManageFocus(" + (0, _reactDisplayName.default)(ComposedComponent) + ")";
  ManageFocus.WrappedComponent = ComposedComponent;
  return ManageFocus;
}