"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactTransitionGroup = require("react-transition-group");

var _reactPopper = require("react-popper");

var _utilsAccessibility = require("@bibliocommons/utils-accessibility");

require("../styles/PopupManager.scss");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var ESCAPE_KEY = 27;

function PopupManager(props) {
  var _useState = (0, _react.useState)(props.initialOpenState),
      expanded = _useState[0],
      setExpanded = _useState[1];

  var doFocus = (0, _react.useRef)();
  var wrapperRef = (0, _react.useRef)();
  var popupRef = (0, _react.useRef)();
  var mouseTargetRef = (0, _react.useRef)(); // Popper.js

  var _useState2 = (0, _react.useState)(null),
      popperTriggerElement = _useState2[0],
      setPopperTriggerElement = _useState2[1];

  var _useState3 = (0, _react.useState)(null),
      popperElement = _useState3[0],
      setPopperElement = _useState3[1];

  var _usePopper = (0, _reactPopper.usePopper)(popperTriggerElement, popperElement, {
    placement: props.rightAligned ? 'bottom-end' : 'bottom-start',
    modifiers: [{
      name: 'preventOverflow',
      options: {
        padding: 20
      }
    }, {
      name: 'offset',
      options: {
        offset: props.offset
      }
    }]
  }),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes; // PopupActions


  var closeContent = (0, _react.useCallback)(function (focus) {
    if (focus === void 0) {
      focus = false;
    }

    if (expanded) {
      setExpanded(false);
      doFocus.current = focus;
    }
  }, [expanded, setExpanded]);
  var focusContent = (0, _react.useCallback)(function () {
    var isActiveElementInPage = !!document.activeElement && document.activeElement !== document.body;

    if (!isActiveElementInPage && popperTriggerElement) {
      (0, _utilsAccessibility.setFocusWithinElement)(popperTriggerElement);
    }
  }, [popperTriggerElement]);
  var closeAndFocusContent = (0, _react.useCallback)(function () {
    closeContent(true);
  }, [closeContent]);

  function openContent() {
    if (!expanded) {
      setExpanded(true);
    }
  }

  function toggleContent() {
    if (expanded) {
      closeContent();
    } else {
      openContent();
    }
  }

  var popupActions = {
    openContent: openContent,
    closeContent: closeContent,
    focusContent: focusContent,
    toggleContent: toggleContent,
    closeAndFocusContent: closeAndFocusContent,
    setPopperElement: setPopperElement,
    styles: styles,
    attributes: attributes
  }; // Event Handlers

  var handleDocumentClick = (0, _react.useCallback)(function (event) {
    if (expanded && wrapperRef.current && !wrapperRef.current.contains(event.target)) {
      closeContent();
    }
  }, [expanded, closeContent]);
  var handleDocumentKeyDown = (0, _react.useCallback)(function (event) {
    // close on escape
    if (event.keyCode === ESCAPE_KEY) {
      closeAndFocusContent();
    }
  }, [closeAndFocusContent]);

  function handleClick() {
    if (expanded && props.closeOnClick) {
      closeContent();
    }
  }

  function handleMouseDown(event) {
    // Clicking a button in some browsers (eg. Safari) does not cause it to receive focus.
    // https://zellwk.com/blog/inconsistent-button-behavior/
    // We store the mouse target to properly handle blur events from mouse clicks. See `handleBlur`.
    if (expanded) {
      mouseTargetRef.current = event.target;
    }
  }

  function handleBlur(event) {
    var relatedTarget = mouseTargetRef.current || event.relatedTarget;
    mouseTargetRef.current = null;

    if (wrapperRef.current && !wrapperRef.current.contains(relatedTarget)) {
      closeContent();
    }
  }

  function handleMouseLeave() {
    if (props.handleMouseLeave) {
      props.handleMouseLeave(popupActions);
    }
  }

  (0, _react.useEffect)(function () {
    if (expanded) {
      document.addEventListener('click', handleDocumentClick, true);
      document.addEventListener('keydown', handleDocumentKeyDown, true);

      if (popupRef.current) {
        // setTimeout with delay of 0 allows the menu to expand before assigning focus within it
        setTimeout(function () {
          return (0, _utilsAccessibility.setFocusWithinElement)(popupRef.current);
        }, 0);
      }
    } else {
      document.removeEventListener('click', handleDocumentClick, true);
      document.removeEventListener('keydown', handleDocumentKeyDown, true);
      if (doFocus.current) focusContent();
    }

    return function () {
      document.removeEventListener('click', handleDocumentClick, true);
      document.removeEventListener('keydown', handleDocumentKeyDown, true);
    };
  }, [expanded, focusContent, handleDocumentClick, handleDocumentKeyDown]);
  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events
    _react.default.createElement("div", {
      onMouseLeave: handleMouseLeave,
      className: "cp-popup-manager " + props.className,
      onBlur: handleBlur,
      onClick: handleClick,
      onMouseDown: handleMouseDown,
      "data-key": props.dataKey,
      ref: wrapperRef
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: "trigger-wrapper",
      ref: setPopperTriggerElement
    }, props.children(popupActions, expanded)), props.hasTransition && /*#__PURE__*/_react.default.createElement(_reactTransitionGroup.CSSTransition, {
      in: expanded,
      classNames: "popup-manager__fade",
      timeout: {
        enter: 150,
        exit: 75
      },
      mountOnEnter: true,
      unmountOnExit: true
    }, /*#__PURE__*/_react.default.createElement("span", {
      ref: popupRef
    }, props.renderContent(popupActions))) || (expanded ? /*#__PURE__*/_react.default.createElement("span", {
      ref: popupRef
    }, props.renderContent(popupActions)) : null))
  );
}

PopupManager.propTypes = {
  dataKey: _propTypes.default.string.isRequired,
  renderContent: _propTypes.default.func.isRequired,
  initialOpenState: _propTypes.default.bool,
  // ToDo: closeOnClick prop should be removed (and behaviour should be as if it's always false)
  // after the switch from deprecated Dropdown and AdditionalItemFormatsDropdown to enhanced components
  closeOnClick: _propTypes.default.bool,
  children: _propTypes.default.func,
  className: _propTypes.default.string,
  handleMouseLeave: _propTypes.default.func,
  hasTransition: _propTypes.default.bool,
  offset: _propTypes.default.arrayOf(_propTypes.default.number),
  rightAligned: _propTypes.default.bool
};
PopupManager.defaultProps = {
  hasTransition: false,
  initialOpenState: false,
  offset: [0, 2]
};
var _default = PopupManager;
exports.default = _default;