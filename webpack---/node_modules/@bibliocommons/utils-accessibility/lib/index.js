"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActiveElement = getActiveElement;
exports.getFocusableElement = getFocusableElement;
exports.getNextFocusableElement = getNextFocusableElement;
exports.setFocusWithinElement = setFocusWithinElement;

var _reactDom = _interopRequireDefault(require("react-dom"));

var HEADINGS_SELECTOR = 'h1, h2, h3, h4, h5, h6';
var FOCUSABLE_SELECTOR = 'a[href], area[href], input:not([disabled]):not([type=hidden]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), object, embed, [tabindex="0"], [tabindex="-1"], [contenteditable], audio[controls], video[controls], summary';

function isMatchingElement(element, selector) {
  var matches = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  return matches.call(element, selector);
}

function isVisibleElement(element) {
  return element.offsetParent && window.getComputedStyle(element).visibility !== 'hidden';
}

function isFocusable(element) {
  return isMatchingElement(element, FOCUSABLE_SELECTOR);
}

function isFocusableAndVisibleElement(element) {
  return isFocusable(element) && isVisibleElement(element);
}
/**
 * Returns the given element or component if it's "focusable" and "visible", otherwise returns the first "focusable"
 * and visible element within it. See the FOCUSABLE_SELECTOR for what's considered a focusable element.
 * @param {HTMLElement|ReactComponent} elementOrComponent
 * @return {HTMLElement}
 */


function getFocusableElement(elementOrComponent) {
  var element = _reactDom.default.findDOMNode(elementOrComponent); // eslint-disable-line react/no-find-dom-node


  if (isFocusableAndVisibleElement(element)) {
    return element;
  }

  var allFocusableElements = element.querySelectorAll(FOCUSABLE_SELECTOR);
  return [].find.call(allFocusableElements, function (focusableElement) {
    return isVisibleElement(focusableElement);
  });
}
/**
 * Gets the first "focusable" and "visible" element which appears in the DOM after the given element or component.
 * @param {HTMLElement|ReactComponent} elementOrComponent
 * @return {HTMLElement}
 */


function getNextFocusableElement(elementOrComponent) {
  var element = _reactDom.default.findDOMNode(elementOrComponent); // eslint-disable-line react/no-find-dom-node


  if (element.nextElementSibling) {
    var focusableElement = getFocusableElement(element.nextElementSibling);
    return focusableElement || getNextFocusableElement(element.nextElementSibling);
  }

  if (element.parentElement) {
    return getNextFocusableElement(element.parentElement);
  }

  return undefined;
}
/**
 * Sets focus on the first "focusable" element within the given element.
 * NOTE: Heading elements are considered "focusable" and are preferred over any other focusable elements
 * within the given element.
 * To override this priority use a "data-focusable" attribute on the element or any descendant
 * that you want to receive focus instead.
 * NOTE: If you already know that your element is natively focusable and visible,
 * then just call .focus() on it. Using this helper will not work.
 * @param {HTMLElement|ReactComponent} elementOrComponent
 */


function setFocusWithinElement(elementOrComponent) {
  var element = _reactDom.default.findDOMNode(elementOrComponent); // eslint-disable-line react/no-find-dom-node


  if (!element) {
    return undefined;
  } // Try setting focus on [data-focusable] and headings first, regardless whether it's focusable or not.


  var preferredElement = element.querySelector('[data-focusable]') || element.querySelector(HEADINGS_SELECTOR);

  if (preferredElement && isVisibleElement(preferredElement)) {
    if (!isFocusable(preferredElement)) {
      preferredElement.setAttribute('tabindex', -1);
    }

    return preferredElement.focus();
  } // Try focusing on the first "focusable" element within it.


  var focusableElement = getFocusableElement(elementOrComponent);

  if (focusableElement) {
    return focusableElement.focus();
  }

  return undefined;
}
/**
 * Handles retrieving activeElement correctly from document; created to handle ie11 inside of an iframe
 * modified from: https://gist.github.com/Alex1990/046a6553dc83e22dd6f4
 * @param {HTMLDocument} document
 * @return {HTMLElement}
 */


function getActiveElement(document) {
  var activeElement;

  try {
    activeElement = document.activeElement;

    if (!activeElement || !activeElement.nodeName) {
      activeElement = document.body;
    }
  } catch (error) {
    activeElement = document.body;
  }

  return activeElement;
}