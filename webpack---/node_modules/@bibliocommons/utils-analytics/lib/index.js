"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBiblioLink = isBiblioLink;
exports.sendAnalyticsEvents = sendAnalyticsEvents;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _urlParse = _interopRequireDefault(require("url-parse"));

var _endsWith = _interopRequireDefault(require("lodash/endsWith"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var CORE_DOMAIN_POSTFIXES = ['.bibliocommons.com', '.bcommons.net'];
/**
 * @definition updates missing parameters from event payload with values of undefined
 * @param {Object} payload
 * @example
 * old payload: {action: 'add', label: 'new'}
 * new payload: {action: 'remove' }
 * returns: {action: 'remove', label: undefined}
 */

function transformPayload(payload) {
  var newPayload = _objectSpread({}, payload);

  var latestBCEvent = [].concat(window.dataLayer).reverse().find(function (event) {
    return event.payload;
  }); // compares the latestBCEvent payload keys to the upcoming event's payload keys

  if (latestBCEvent) {
    Object.keys(latestBCEvent.payload).forEach(function (key) {
      // if a key is missing on the upcoming payload, define it as undefined;
      // this prevents the new payload from using the old payload values
      if (!Object.prototype.hasOwnProperty.call(newPayload, key)) {
        newPayload[key] = undefined;
      }
    });
  }

  return newPayload;
}
/**
 * @definition pushes current analytic event to data layer for tracking
 * @param {Array} analytics holds events array which holds objects with following shape: { event, payload }
 */


function sendAnalyticsEvents(analytics) {
  if (analytics && analytics.events) {
    analytics.events.forEach(function (event) {
      if (event.event) {
        if (typeof window !== 'undefined' && window.dataLayer && typeof window.dataLayer.push === 'function') {
          window.dataLayer.push({
            event: event.event,
            payload: transformPayload(event.payload)
          });
        }
      }
    });
  }
}

function isCmsHostname(hostname) {
  if (typeof window !== 'undefined' && window.dataLayer) {
    var data = window.dataLayer[0] || {};
    var cmsUrl = data['bc.cmsUrl'];

    if (cmsUrl) {
      var cmsHostname = new _urlParse.default(cmsUrl).hostname;
      return cmsHostname === hostname;
    }
  }

  return false;
}

function isCoreHostname(hostname) {
  return CORE_DOMAIN_POSTFIXES.some(function (biblioDomainPostfix) {
    return (0, _endsWith.default)(hostname, biblioDomainPostfix);
  });
}
/**
 * Checks if a URL should be considered internal to Bibliocommons,
 * for the purposes of internal analytics tracking.
 *
 * A URL is "external" if the domain is not CORE or Web.
 *
 * @param {string} url
 * @returns {boolean}
 */


function isBiblioLink(url) {
  var _URL = new _urlParse.default(url),
      hostname = _URL.hostname;

  return isCoreHostname(hostname) || isCmsHostname(hostname);
}