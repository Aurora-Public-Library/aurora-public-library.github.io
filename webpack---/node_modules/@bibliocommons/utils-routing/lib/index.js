"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryToSearch = queryToSearch;
exports.searchToQuery = searchToQuery;
exports.useQuery = useQuery;
exports.useRouter = useRouter;
exports.withOptionalRouter = withOptionalRouter;
exports.withRouter = withRouter;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _pickBy = _interopRequireDefault(require("lodash/pickBy"));

var _querystring = _interopRequireDefault(require("querystring"));

var _reactDisplayName = _interopRequireDefault(require("react-display-name"));

var _hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));

var _reactRouterDom = require("react-router-dom");

var _excluded = ["router"];

/**
 * Converts a location search string into an object of query string parameters.
 * @param {string} search
 * @return {object}
 */
function searchToQuery(search) {
  if (!search) return {};
  var str = search.indexOf('?') === 0 ? search.slice(1) : search;
  return _querystring.default.parse(str);
}
/**
 * Converts an object of query string parameters into a location search string.
 * NOTE: It removes empty and falsy values from the generated string.
 * @param {object} query
 * @return {string}
 */


function queryToSearch(query) {
  var normalizedQuery = (0, _pickBy.default)(query, function (val) {
    return Array.isArray(val) ? val.length > 0 : !!val;
  });

  var str = _querystring.default.stringify(normalizedQuery);

  return str ? "?" + str : '';
}
/**
 * React hook for accessing the current location query string object.
 * @return {object}
 */


function useQuery() {
  return searchToQuery((0, _reactRouterDom.useLocation)().search);
}
/**
 * React hook for accessing a custom router object, with various location functions and properties.
 * To be used for navigation, generating urls and accessing location parameters.
 * @return {object}
 */


function useRouter() {
  var history = (0, _reactRouterDom.useHistory)();
  var location = (0, _reactRouterDom.useLocation)();
  var params = (0, _reactRouterDom.useParams)();
  var query = useQuery();

  function createRouter() {
    function _createHref(to) {
      var pathname = to.pathname || location.pathname;
      var search = to.query ? queryToSearch(to.query) : to.search;
      return history.createHref({
        pathname: pathname,
        search: search,
        hash: to.hash
      });
    }

    function navigate(action, to) {
      if (typeof to === 'string') return history[action](to);
      return history[action](_createHref(to));
    }

    return {
      location: location,
      params: params,
      query: query,
      push: function push(to) {
        return navigate('push', to);
      },
      replace: function replace(to) {
        return navigate('replace', to);
      },
      createHref: function createHref(to) {
        return _createHref(to);
      }
    };
  } // Add logic to return a new router object only when the location has changed.
  // This would allow components to rely on reference equality, to also determine
  // whether the location has changed.
  // NOTE: We're checking `location.key` here because we need to ignore changes
  // to the `location` object that do not come from react-router. For example,
  // the Modal component uses window.history.pushState to handle closing with the
  // browser back button, but that should not be considered a router transition.
  // The `location.key` property is only updated by react-router during transition.


  var routerRef = _react.default.useRef(createRouter());

  if (routerRef.current.location.key !== location.key) {
    routerRef.current = createRouter();
  }

  return routerRef.current;
}
/**
 * HOC for accessing the custom router object.
 * @return {Component}
 */


function withRouter(WrappedComponent) {
  var Wrapper = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
    // Use the exported version of `useRouter`, to support mocking the router in tests
    var router = exports.useRouter();
    return /*#__PURE__*/_react.default.createElement(WrappedComponent, (0, _extends2.default)({}, props, {
      ref: ref,
      router: router
    }));
  });

  Wrapper.WrappedComponent = WrappedComponent;
  Wrapper.displayName = "withRouter(" + (0, _reactDisplayName.default)(WrappedComponent) + ")";
  return (0, _hoistNonReactStatics.default)(Wrapper, WrappedComponent);
}
/**
 * HOC similar to `withRouter`, except the router may be optionally passed.
 * To omit the router simply pass `router={false}` to the wrapper component.
 * @return {Component}
 */


function withOptionalRouter(WrappedComponent) {
  var WithRouterComponent = withRouter(WrappedComponent);

  var OptionalRouterComponent = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
    var _ref$router = _ref.router,
        router = _ref$router === void 0 ? true : _ref$router,
        props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    var Component = router ? WithRouterComponent : WrappedComponent;
    return /*#__PURE__*/_react.default.createElement(Component, (0, _extends2.default)({}, props, {
      ref: ref
    }));
  });

  OptionalRouterComponent.propTypes = {
    router: _propTypes.default.bool
  };
  OptionalRouterComponent.WrappedComponent = WrappedComponent;
  OptionalRouterComponent.displayName = "withOptionalRouter(" + (0, _reactDisplayName.default)(WrappedComponent) + ")";
  return (0, _hoistNonReactStatics.default)(OptionalRouterComponent, WrappedComponent);
}